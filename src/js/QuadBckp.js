// Generated by CoffeeScript 1.6.3
(function() {
  var Quad,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Quad = (function() {
    function Quad(width, height, canvasKeyboard, scene) {
      this.computeTextureProjection = __bind(this.computeTextureProjection, this);
      this.mouseUp = __bind(this.mouseUp, this);
      this.mouseMove = __bind(this.mouseMove, this);
      this.mouseDown = __bind(this.mouseDown, this);
      var C, face, i, m, margin, normal, position, ratio, s, shaderMaterial, uv0, uv1, uv2, uv3, _i, _j, _len, _ref;
      this.sceneX = scene.$container.position().left;
      this.sceneY = scene.$container.position().top;
      this.sceneWidth = scene.width;
      this.sceneHeight = scene.height;
      this.projector = new THREE.Projector();
      this.camera = scene.sceneOrtho;
      margin = 50;
      ratio = height / width;
      width = scene.width - 2 * margin;
      height = width * ratio;
      console.log(width);
      console.log(height);
      this.geometry = new THREE.Geometry();
      normal = new THREE.Vector3(0, 0, 1);
      this.positions = [];
      this.positions.push({
        x: -width / 2,
        y: height / 2
      });
      this.positions.push({
        x: width / 2,
        y: height / 2
      });
      this.positions.push({
        x: -width / 2,
        y: -height / 2
      });
      this.positions.push({
        x: width / 2,
        y: -height / 2
      });
      _ref = this.positions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        this.geometry.vertices.push(new THREE.Vector3(position.x, position.y, 0));
      }
      uv0 = new THREE.Vector4(0, 1, 0, 1);
      uv1 = new THREE.Vector4(1, 1, 0, 1);
      uv2 = new THREE.Vector4(0, 0, 0, 1);
      uv3 = new THREE.Vector4(1, 0, 0, 1);
      face = new THREE.Face3(0, 3, 1);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.geometry.faces.push(face);
      this.geometry.faceVertexUvs[0].push([uv0.clone(), uv3.clone(), uv1.clone()]);
      face = new THREE.Face3(1, 3, 2);
      face.normal.copy(normal);
      face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
      this.geometry.faces.push(face);
      this.geometry.faceVertexUvs[0].push([uv1.clone(), uv3.clone(), uv2.clone()]);
      this.geometry.computeCentroids();
      this.texture = new THREE.Texture(canvasKeyboard[0]);
      this.texture.needsUpdate = true;
      C = new THREE.Matrix3();
      this.Ainv = new THREE.Matrix3(-1, 2, 0, 1, 0, 2, 1, 0, 0);
      this.uniforms = {
        texture: {
          type: "t",
          value: this.texture
        },
        resolution: {
          type: "v2",
          value: new THREE.Vector2(this.screenWidth, this.screenHeight)
        },
        matC: {
          type: "m3",
          value: C
        }
      };
      shaderMaterial = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: $('#vertexshader').text(),
        fragmentShader: $('#fragmentshader').text()
      });
      this.mesh = new THREE.Mesh(this.geometry, shaderMaterial);
      this.mesh.position.set(0, 0, 1);
      scene.add(this.mesh);
      this.sprites = [];
      for (i = _j = 0; _j <= 3; i = ++_j) {
        position = this.positions[i];
        m = new THREE.SpriteMaterial({
          color: new THREE.Color('green'),
          useScreenCoordinates: true
        });
        s = new THREE.Sprite(m);
        s.scale.set(32, 32, 1.0);
        s.position.set(position.x, position.y, 1);
        scene.add(s);
        this.sprites.push(s);
      }
      scene.$container.mousedown(this.mouseDown);
      scene.$container.mousemove(this.mouseMove);
      scene.$container.mouseup(this.mouseUp);
    }

    Quad.prototype.screenToWorld = function(mouseX, mouseY) {
      return new THREE.Vector3(mouseX - this.sceneX - this.sceneWidth / 2, -(mouseY - this.sceneY) + this.sceneHeight / 2, 1);
    };

    Quad.prototype.worldToScreen = function(pos) {
      return new THREE.Vector2((pos.x / this.sceneWidth) + 0.5, -(pos.y / this.sceneHeight) + 0.5);
    };

    Quad.prototype.mouseDown = function(event) {
      var i, mousePos, sprite, _i, _len, _ref, _results;
      mousePos = this.screenToWorld(event.pageX, event.pageY);
      _ref = this.sprites;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        sprite = _ref[i];
        if (sprite.position.distanceTo(mousePos) < 32) {
          this.selectedSprite = sprite;
          _results.push(this.selectedIndex = i);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Quad.prototype.mouseMove = function(event) {
      var mousePos;
      console.log(event.pageY);
      console.log(-(event.pageY - this.sceneY) + this.sceneHeight / 2);
      if (this.selectedSprite != null) {
        mousePos = this.screenToWorld(event.pageX, event.pageY);
        this.selectedSprite.position.copy(mousePos);
        this.mesh.geometry.vertices[this.selectedIndex] = mousePos;
        return this.mesh.geometry.verticesNeedUpdate = true;
      }
    };

    Quad.prototype.mouseUp = function(event) {
      var mousePos, _ref;
      if (this.selectedSprite != null) {
        mousePos = this.screenToWorld(event.pageX, event.pageY);
        if ((_ref = this.selectedSprite) != null) {
          _ref.position.copy(mousePos);
        }
        this.mesh.geometry.vertices[this.selectedIndex] = mousePos;
        this.mesh.geometry.verticesNeedUpdate = true;
        this.selectedSprite = null;
        return this.selectedIndex = -1;
      }
    };

    Quad.prototype.inverseMatrix = function(a) {
      var a11, a12, a13, a21, a22, a23, a31, a32, a33, ae, detA, t, te;
      ae = a.elements;
      t = new THREE.Matrix3();
      te = t.elements;
      a11 = ae[0];
      a12 = ae[3];
      a13 = ae[6];
      a21 = ae[1];
      a22 = ae[4];
      a23 = ae[7];
      a31 = ae[2];
      a32 = ae[5];
      a33 = ae[8];
      detA = a11 * a22 * a33 + a21 * a32 * a13 + a31 * a12 * a23 - a11 * a32 * a23 - a31 * a22 * a13 - a21 * a12 * a33;
      te[0] = a22 * a33 - a23 * a32;
      te[3] = a13 * a32 - a12 * a33;
      te[6] = a12 * a23 - a13 * a22;
      te[1] = a23 * a31 - a21 * a33;
      te[4] = a11 * a33 - a13 * a31;
      te[7] = a13 * a21 - a11 * a23;
      te[2] = a21 * a32 - a22 * a31;
      te[5] = a12 * a31 - a11 * a32;
      te[8] = a11 * a22 - a12 * a21;
      return t;
    };

    Quad.prototype.multiplyMatrices = function(a, b) {
      var a11, a12, a13, a21, a22, a23, a31, a32, a33, ae, b11, b12, b13, b21, b22, b23, b31, b32, b33, be, t, te;
      ae = a.elements;
      be = b.elements;
      t = new THREE.Matrix3();
      te = t.elements;
      a11 = ae[0];
      a12 = ae[3];
      a13 = ae[6];
      a21 = ae[1];
      a22 = ae[4];
      a23 = ae[7];
      a31 = ae[2];
      a32 = ae[5];
      a33 = ae[8];
      b11 = be[0];
      b12 = be[3];
      b13 = be[6];
      b21 = be[1];
      b22 = be[4];
      b23 = be[7];
      b31 = be[2];
      b32 = be[5];
      b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return t;
    };

    Quad.prototype.computeTextureProjection = function() {
      var A, Ainv, B, C, Cinv, dstMat, dstMatInv, pos1, pos2, pos3, pos4, srcMat, srcMatInv, srcVars, uv1, uv1p, vars;
      pos1 = this.worldToScreen(this.sprites[0].position);
      pos2 = this.worldToScreen(this.sprites[1].position);
      pos3 = this.worldToScreen(this.sprites[2].position);
      pos4 = this.worldToScreen(this.sprites[3].position);
      srcMat = new THREE.Matrix3(0, 1, 0, 1, 1, 0, 1, 1, 1);
      srcMatInv = this.inverseMatrix(srcMat);
      srcVars = srcMatInv.multiplyVector3Array([pos4.x, pos4.y, 1]);
      A = new THREE.Matrix3(0, srcVars[1], 0, srcVars[0], srcVars[1], 0, srcVars[0], srcVars[1], srcVars[2]);
      dstMat = new THREE.Matrix3(pos1.x, pos2.x, pos3.x, pos1.y, pos2.y, pos3.y, 1, 1, 1);
      dstMatInv = this.inverseMatrix(dstMat);
      vars = dstMatInv.multiplyVector3Array([pos4.x, pos4.y, 1]);
      B = new THREE.Matrix3(pos1.x * vars[0], pos2.x * vars[1], pos3.x * vars[2], pos1.y * vars[0], pos2.y * vars[1], pos3.y * vars[2], vars[0], vars[1], vars[2]);
      Ainv = this.inverseMatrix(A);
      C = this.multiplyMatrices(this.Ainv, B);
      Cinv = this.inverseMatrix(C);
      console.log(dstMat.elements);
      console.log(dstMatInv.elements);
      console.log(vars);
      console.log(A.elements);
      console.log(Ainv.elements);
      console.log(B.elements);
      console.log(C.elements);
      console.log(Cinv.elements);
      console.log(pos1);
      uv1 = C.multiplyVector3Array([pos1.x, pos1.y, 1]);
      uv1p = Cinv.multiplyVector3Array([pos1.x, pos1.y, 1]);
      console.log("uv1: x:" + uv1[0] / uv1[2] + ", y:" + uv1[1] / uv1[2]);
      console.log("uv1p: x:" + uv1p[0] / uv1p[2] + ", y:" + uv1p[1] / uv1p[2]);
      return this.uniforms["matC"].value = C;
    };

    return Quad;

  })();

  this.Quad = Quad;

}).call(this);
