// Generated by CoffeeScript 1.10.0
(function() {
  var NoteRain,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  NoteRain = (function() {
    NoteRain.prototype.lengthScale = 0.001;

    function NoteRain(pianoDesign) {
      this.pianoDesign = pianoDesign;
      this.update = bind(this.update, this);
      this.model = new THREE.Object3D();
    }

    NoteRain.prototype.setMidiData = function(midiData, callback) {
      this.clear();
      this.noteInfos = this._getNoteInfos(midiData);
      return this._buildNoteMeshes(this.noteInfos, callback);
    };

    NoteRain.prototype.clear = function() {
      var child, j, len, ref, results;
      ref = this.model.children.slice(0);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        results.push(this.model.remove(child));
      }
      return results;
    };

    NoteRain.prototype._getNoteInfos = function(midiData) {
      var channel, currentTime, duration, event, interval, j, len, noteInfos, noteNumber, noteTimes, ref, ref1, startTime, subtype, velocity;
      currentTime = 0;
      noteInfos = [];
      noteTimes = [];
      for (j = 0, len = midiData.length; j < len; j++) {
        ref = midiData[j], (ref1 = ref[0], event = ref1.event), interval = ref[1];
        currentTime += interval;
        subtype = event.subtype, noteNumber = event.noteNumber, channel = event.channel, velocity = event.velocity;
        if (channel === 9) {
          continue;
        }
        if (subtype === 'noteOn') {
          noteTimes[noteNumber] = currentTime;
        } else if (subtype === 'noteOff') {
          startTime = noteTimes[noteNumber];
          duration = currentTime - startTime;
          noteInfos.push({
            noteNumber: noteNumber,
            startTime: startTime,
            duration: duration,
            velocity: velocity
          });
        }
      }
      return noteInfos;
    };

    NoteRain.prototype._buildNoteMeshes = function(noteInfos, callback) {
      var Black, KeyType, SIZE_OF_EACH_GROUP, blackKeyHeight, blackKeyWidth, group, groups, j, keyInfo, len, noteToColor, ref, sleepTask, splitToGroups, tasks;
      ref = this.pianoDesign, blackKeyWidth = ref.blackKeyWidth, blackKeyHeight = ref.blackKeyHeight, keyInfo = ref.keyInfo, KeyType = ref.KeyType, noteToColor = ref.noteToColor;
      Black = KeyType.Black;
      splitToGroups = function(items, sizeOfEachGroup) {
        var groups, i, j, numGroups, ref1, start;
        groups = [];
        numGroups = Math.ceil(items.length / sizeOfEachGroup);
        start = 0;
        for (i = j = 0, ref1 = numGroups; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          groups[i] = items.slice(start, start + sizeOfEachGroup);
          start += sizeOfEachGroup;
        }
        return groups;
      };
      sleepTask = function(done) {
        return setTimeout((function() {
          return done(null);
        }), 0);
      };
      tasks = [];
      SIZE_OF_EACH_GROUP = 100;
      groups = splitToGroups(noteInfos, SIZE_OF_EACH_GROUP);
      for (j = 0, len = groups.length; j < len; j++) {
        group = groups[j];
        tasks.push(sleepTask);
        tasks.push((function(_this) {
          return function(group) {
            return function(done) {
              var color, duration, geometry, k, len1, length, material, mesh, noteInfo, noteNumber, startTime, x, y, z;
              for (k = 0, len1 = group.length; k < len1; k++) {
                noteInfo = group[k];
                noteNumber = noteInfo.noteNumber, startTime = noteInfo.startTime, duration = noteInfo.duration;
                length = duration * _this.lengthScale;
                x = keyInfo[noteNumber].keyCenterPosX;
                y = startTime * _this.lengthScale + (length / 2);
                z = -0.2;
                if (keyInfo[noteNumber].keyType === Black) {
                  y += blackKeyHeight / 2;
                }
                color = noteToColor(noteNumber);
                geometry = new THREE.CubeGeometry(blackKeyWidth, length, blackKeyWidth);
                material = new THREE.MeshPhongMaterial({
                  color: color,
                  emissive: color,
                  opacity: 0.7,
                  transparent: true
                });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                _this.model.add(mesh);
              }
              return done(null);
            };
          };
        })(this)(group));
      }
      return async.series(tasks, function() {
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    NoteRain.prototype.update = function(playerCurrentTime) {
      return this.model.position.y = -playerCurrentTime * this.lengthScale;
    };

    return NoteRain;

  })();

  this.NoteRain = NoteRain;

}).call(this);
