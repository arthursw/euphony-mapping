// Generated by CoffeeScript 1.10.0
(function() {
  var NoteRain2D,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  NoteRain2D = (function() {
    NoteRain2D.prototype.lengthScale = 0.001;

    function NoteRain2D(pianoDesign, keyboard2D, app) {
      var background, i, j, keyInfo, len, line, ref, x;
      this.pianoDesign = pianoDesign;
      this.keyboard2D = keyboard2D;
      this.update = bind(this.update, this);
      this.keyUnitToPixelsRatio = this.keyboard2D.keyUnitToPixelsRatio;
      this.offsetX = this.keyboard2D.offsetX;
      this.group = new paper.Group();
      this.background = new paper.Group();
      background = paper.Path.Rectangle(0, 0, this.keyboard2D.canvasWidth, this.keyboard2D.canvasHeight);
      background.fillColor = '#303030';
      this.background.addChild(background);
      ref = this.pianoDesign.keyInfo;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        keyInfo = ref[i];
        if (i >= this.keyboard2D.begin && i <= this.keyboard2D.end && (keyInfo.keyType === this.pianoDesign.KeyType.WhiteC || keyInfo.keyType === this.pianoDesign.KeyType.WhiteF || keyInfo.keyType === this.pianoDesign.KeyType.Black)) {
          line = new paper.Path();
          line.strokeWidth = 1;
          line.strokeColor = '#bfbebb';
          x = (keyInfo.keyCenterPosX + this.offsetX - this.pianoDesign.whiteKeyWidth * 0.5) * this.keyUnitToPixelsRatio;
          if (keyInfo.keyType === this.pianoDesign.KeyType.Black) {
            line.strokeColor = '#393939';
            line.strokeWidth = this.pianoDesign.blackKeyWidth * this.keyboard2D.keyUnitToPixelsRatio;
            x = (keyInfo.keyCenterPosX + this.offsetX) * this.keyUnitToPixelsRatio;
          }
          line.add(new paper.Point(x, 0));
          line.add(new paper.Point(x, this.keyboard2D.canvasHeight));
          this.background.addChild(line);
        }
      }
      this.horizontalLinesGroup = new paper.Group();
      this.onTimeDivisionChange(app.timeDivision, app.measureDuration);
      this.horizontalLinesGroup.moveAbove(this.background);
      this.group.moveAbove(this.horizontalLinesGroup);
      this.keyboard2D.group.moveAbove(this.group);
      return;
    }

    NoteRain2D.prototype.setMidiData = function(midiData, callback) {
      this.clear();
      this.noteInfos = this._getNoteInfos(midiData);
      return this._buildNoteMeshes(this.noteInfos, callback);
    };

    NoteRain2D.prototype.clear = function() {
      this.group.removeChildren();
    };

    NoteRain2D.prototype.createNote = function(noteInfo, offsetY) {
      var Black, KeyType, blackKeyHeight, blackKeyWidth, color, deltaY, duration, keyCenterPosX, keyInfo, keyType, length, noteNumber, noteToColor, rectangle, ref, ref1, startTime, whiteKeyWidth, width, x, y, yInPixels;
      if (offsetY == null) {
        offsetY = false;
      }
      ref = this.pianoDesign, whiteKeyWidth = ref.whiteKeyWidth, blackKeyWidth = ref.blackKeyWidth, blackKeyHeight = ref.blackKeyHeight, keyInfo = ref.keyInfo, KeyType = ref.KeyType, noteToColor = ref.noteToColor;
      Black = KeyType.Black;
      noteNumber = noteInfo.noteNumber, startTime = noteInfo.startTime, duration = noteInfo.duration;
      ref1 = keyInfo[noteNumber], keyType = ref1.keyType, keyCenterPosX = ref1.keyCenterPosX;
      length = duration * this.lengthScale;
      x = keyCenterPosX;
      y = -startTime * this.lengthScale - length;
      color = noteToColor(noteNumber);
      color = '#7aa5d7';
      width = whiteKeyWidth;
      if (keyType === Black) {
        color = '#9ae05f';
        x += this.offsetX - blackKeyWidth * 0.5;
        width = blackKeyWidth;
      } else {
        x += this.offsetX - whiteKeyWidth * 0.5;
        width = whiteKeyWidth;
      }
      yInPixels = this.keyUnitToPixelsRatio * y;
      if (offsetY) {
        deltaY = yInPixels - this.bounds.centerY;
        yInPixels = this.group.position.y + deltaY;
      }
      rectangle = new paper.Path.Rectangle(this.keyUnitToPixelsRatio * x, yInPixels, this.keyUnitToPixelsRatio * width, this.keyUnitToPixelsRatio * length);
      rectangle.fillColor = color;
      noteInfo.rectangle = rectangle;
      this.group.addChild(rectangle);
    };

    NoteRain2D.prototype.toggleNote = function(note) {
      var i, j, len, noteFound, noteIndex, noteInfo, noteTime, ref;
      console.log("toggle note: " + note);
      noteFound = false;
      noteIndex = 0;
      noteTime = note.startTime;
      ref = this.noteInfos;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        noteInfo = ref[i];
        if (noteInfo.startTime < noteTime) {
          noteIndex++;
        } else if (noteInfo.startTime >= noteTime && noteInfo.startTime <= noteTime + app.measureDuration * app.noteDuration && noteInfo.noteNumber === note.noteNumber) {
          noteInfo.rectangle.remove();
          this.noteInfos.splice(i, 1);
          noteFound = true;
          break;
        }
      }
      if (!noteFound) {
        this.createNote(note, true);
        this.noteInfos.splice(noteIndex, 0, note);
      }
    };

    NoteRain2D.prototype._getNoteInfos = function(midiData) {
      var channel, currentTime, duration, event, interval, j, len, noteInfos, noteNumber, noteTimes, ref, ref1, startTime, subtype, velocity;
      currentTime = 0;
      noteInfos = [];
      noteTimes = [];
      for (j = 0, len = midiData.length; j < len; j++) {
        ref = midiData[j], (ref1 = ref[0], event = ref1.event), interval = ref[1];
        currentTime += interval;
        subtype = event.subtype, noteNumber = event.noteNumber, channel = event.channel, velocity = event.velocity;
        if (channel === 9) {
          continue;
        }
        if (subtype === 'noteOn') {
          noteTimes[noteNumber] = currentTime;
        } else if (subtype === 'noteOff') {
          startTime = noteTimes[noteNumber];
          duration = currentTime - startTime;
          noteInfos.push({
            noteNumber: noteNumber,
            startTime: startTime,
            duration: duration,
            velocity: velocity
          });
        }
      }
      return noteInfos;
    };

    NoteRain2D.prototype._noteInfosToMidiData = function(noteInfos) {
      var currentTime, event, j, k, len, len1, midiData, noteInfo, noteTimes, previousTime, t;
      midiData = [];
      for (j = 0, len = noteInfos.length; j < len; j++) {
        noteInfo = noteInfos[j];
        event = {
          subtype: 'noteOn',
          noteNumber: noteInfo.noteNumber,
          channel: 1,
          velocity: noteInfo.velocity
        };
        midiData.push([
          {
            event: event
          }, noteInfo.startTime
        ]);
        event = {
          subtype: 'noteOff',
          noteNumber: noteInfo.noteNumber,
          channel: 1,
          velocity: noteInfo.velocity
        };
        midiData.push([
          {
            event: event
          }, noteInfo.startTime + noteInfo.duration
        ]);
      }
      midiData.sort(function(a, b) {
        return a[1] - b[1];
      });
      previousTime = 0;
      for (k = 0, len1 = midiData.length; k < len1; k++) {
        event = midiData[k];
        t = previousTime;
        previousTime = event[1];
        event[1] -= t;
      }
      currentTime = 0;
      noteInfos = [];
      noteTimes = [];
      return midiData;
    };

    NoteRain2D.prototype._buildNoteMeshes = function(noteInfos, callback) {
      var i, j, len, noteInfo;
      for (i = j = 0, len = noteInfos.length; j < len; i = ++j) {
        noteInfo = noteInfos[i];
        this.createNote(noteInfo);
      }
      if (typeof callback === "function") {
        callback();
      }
      this.bounds = this.group.getBounds();
      this.group.addChild(this.horizontalLinesGroup);
      this.horizontalLinesGroup.position.y = this.bounds.bottom - this.horizontalLinesGroup.bounds.height * 0.5;
    };

    NoteRain2D.prototype.update = function(playerCurrentTime) {
      this.group.position.y = -this.bounds.height * 0.5 + this.keyboard2D.canvasHeight - this.keyboard2D.keyboardHeightInPixel + playerCurrentTime * this.lengthScale * this.keyUnitToPixelsRatio;
      if (this.horizontalLinesGroup.bounds.bottom > this.keyboard2D.canvasHeight + this.horizontalLinesStep) {
        this.horizontalLinesGroup.position.y -= this.horizontalLinesStep;
      }
    };

    NoteRain2D.prototype.onTimeDivisionChange = function(timeDivision, measureDuration) {
      var line, t, y;
      if (timeDivision == null) {
        timeDivision = app.timeDivision;
      }
      if (measureDuration == null) {
        measureDuration = app.measureDuration;
      }
      this.horizontalLinesGroup.removeChildren();
      y = this.horizontalLinesGroup.bounds.top;
      t = 0;
      this.horizontalLinesStep = measureDuration * this.lengthScale * this.keyUnitToPixelsRatio;
      while (y < this.keyboard2D.canvasHeight) {
        line = new paper.Path();
        line.stokeWidth = 1;
        line.strokeColor = '#bfbebb';
        switch (t % measureDuration) {
          case 0:
            line.strokeColor.alpha = 1;
            break;
          case measureDuration * 0.5:
            line.strokeColor.alpha = 0.5;
            break;
          case measureDuration * 0.25:
          case measureDuration * 0.75:
            line.strokeColor.alpha = 0.25;
            break;
          default:
            line.strokeColor.alpha = 0.1;
        }
        line.add(new paper.Point(0, y));
        line.add(new paper.Point(this.keyboard2D.canvasWidth, y));
        this.horizontalLinesGroup.addChild(line);
        t += timeDivision * measureDuration;
        y = t * this.lengthScale * this.keyUnitToPixelsRatio;
      }
    };

    return NoteRain2D;

  })();

  this.NoteRain2D = NoteRain2D;

}).call(this);
